set termguicolors

set clipboard+=unnamedplus,unnamed

" === SHOW MATCH PAREN AND SET DELAY
set showmatch
set matchtime=3

" Theme ; ordonnancement et appel complexe des fichiers d'initialisation ;
" https://neovim.io/doc/user/options.html#'runtimepath'
" https://neovim.io/doc/user/starting.html#$VIMRUNTIME
" https://neovim.io/doc/user/syntax.html#:colorscheme
" https://neovim.io/doc/user/syntax.html#syncolor
" https://neovim.io/doc/user/syntax.html#syntax
" https://neovim.io/doc/user/usr_06.html
" :hi highlight et voisinage des entr√©es ci-dessus
"
"syntax enable
colorscheme mine


" Specify a directory for plugins
" - For Neovim: ~/.local/share/nvim/plugged
" - Avoid using standard Vim directory names like 'plugin'
call plug#begin()



" Make sure you use single quotes

" === LEAN & MEAN STATUS/TABLINE FOR VIM THAT'S LIGHT AS AIR
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'

" === PERFORM ALL YOUR VIM INSERT MODE COMPLETIONS WITH TAB
Plug 'ervandew/supertab'

"Plug 'fsharp/vim-fsharp', {
"      \ 'for': 'fsharp',
"      \ 'do':  'make fsautocomplete',
"      \}

" === SLOW ?? OU FSHARP ??
" === C'EST AU CHARGEMENT POUR F#
Plug 'vim-syntastic/syntastic'

" === D√âPENDANCE POUR SYNTASTIC ??
Plug 'tpope/vim-fugitive'

" === RAINBOW PARENTHESIS FOR LISP ()()()((((())()(()))))
"Plug 'amdt/vim-niji'
Plug 'kien/rainbow_parentheses.vim'


" === FAST MOTION ===
Plug 'easymotion/vim-easymotion'


" === utilise ocamlformat et ocp-indent pour formater
Plug 'sbdchd/neoformat'

" === vim-ocaml syntax files for vim/neovim
Plug 'ocaml/vim-ocaml'

" === LSP Language Server Protocol support
Plug 'autozimu/LanguageClient-neovim', {
    \ 'branch': 'next',
    \ 'do': 'bash install.sh',
    \ }

" (Optional) Multi-entry selection UI.
" Plug 'junegunn/fzf'

Plug 'ionide/Ionide-vim', {
      \ 'do':  'make fsautocomplete',
      \}

" ghcid buffer for neovim, broken ? can't invoke, wtf
"Plug 'ndmitchell/ghcid', { 'rtp': 'plugins/nvim' }


Plug 'neovimhaskell/haskell-vim'  "indentation , syntax files


" Initialize plugin system
call plug#end()

"=== END OF PLUGS

let g:haskell_enable_quantification = 1   " to enable highlighting of `forall`
let g:haskell_enable_recursivedo = 1      " to enable highlighting of `mdo` and `rec`
let g:haskell_enable_arrowsyntax = 1      " to enable highlighting of `proc`
let g:haskell_enable_pattern_synonyms = 1 " to enable highlighting of `pattern`
let g:haskell_enable_typeroles = 1        " to enable highlighting of type roles
let g:haskell_enable_static_pointers = 1  " to enable highlighting of `static`
let g:haskell_backpack = 1                " to enable highlighting of backpack keywords
let g:haskell_classic_highlighting = 1
"let g:haskell_indent_disable = 1



"DEBUG MODE
 " only affects the verbosity of Neoformat
"let g:neoformat_verbose = 1
" also increases verbosity of the editor as a whole
"let &verbose            = 1

let g:neoformat_ocaml_ocamlformat = {
            \ 'exe': 'ocamlformat',
            \ 'no_append': 1,
            \ 'stdin': 1,
            \ 'args': ['--enable-outside-detected-project', '--name', '"%:p"', '-']
            \ }

" Configuration and activation of ocamlformat+ocp-indet for neoformat
let g:neoformat_enabled_ocaml = ['ocamlformat']
" si non d√©fini, le premier trouv√© ou erreur
let g:neoformat_enabled_haskell = ['ormolu']

"let g:ormolu_ghc_opt=["TypeApplications", \\\\\\\""""\"RankNTypes"]

" Configuration variables for vim-airline
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = 'default'
"let g:airline_powerline_fonts = 1
if !exists('g:airline_symbols')
let g:airline_symbols = {}
endif

" unicode symbols
let g:airline_left_sep = '¬ª'
let g:airline_left_sep = '‚ñ∂'
let g:airline_right_sep = '¬´'
let g:airline_right_sep = '‚óÄ'
let g:airline_symbols.crypt = 'üîí'
let g:airline_symbols.linenr = '‚ò∞'
let g:airline_symbols.linenr = '‚êä'
let g:airline_symbols.linenr = '‚ê§'
let g:airline_symbols.linenr = '¬∂'
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.maxlinenr = '„èë'
let g:airline_symbols.branch = '‚éá'
let g:airline_symbols.paste = 'œÅ'
let g:airline_symbols.paste = '√û'
let g:airline_symbols.paste = '‚à•'
let g:airline_symbols.spell = 'Íû®'
let g:airline_symbols.notexists = '…Ü'
let g:airline_symbols.whitespace = 'Œû'

" powerline symbols
let g:airline_left_sep = 'ÓÇ∞'
let g:airline_left_alt_sep = 'ÓÇ±'
let g:airline_right_sep = 'ÓÇ≤'
let g:airline_right_alt_sep = 'ÓÇ≥'
let g:airline_symbols.branch = 'ÓÇ†'
let g:airline_symbols.readonly = 'ÓÇ¢'
let g:airline_symbols.linenr = '‚ò∞'
let g:airline_symbols.maxlinenr = 'ÓÇ°'
let g:airline_symbols.dirty='‚òá'



let g:airline_theme = 'light'
let g:airline_highlighting_cache = 1
"let g:airline_extensions = [] "select extensions to be loaded

"?let g:airline#extensions#branch#enabled = 1
let g:airline#extensions#branch#format = 2


" === F# FSHARP CONFIG === (DEFAULT_ARG)
" By default your F# files will be syntax/type checked on every open/save of a vim buffer as well as after 500ms of inactivity in Normal mode. 
" In case you would prefer not to have you errors checked continuously add the following to your vimrc (0)
let g:fsharp_only_check_errors_on_write = 1

" In case you prefer to disable the syntax checker, add the following to your vimrc ('syntax')
"let g:syntastic_fsharp_checkers = ['']

" If you find the default bindings unsuitable then it is possible to turn them off (1)
"let g:fsharp_map_keys = 0

" Automatically open the result of an FsiEval (fsi-out buffer) in a vsplit window (0)
let g:fsharp_fsi_show_auto_open = 1

" This sets maps hereafter in a if directive.
" If you find the default bindings unsuitable then it is possible to turn them off. (1)
"let g:fsharp_map_keys = 0

" === Overrides the default mappings ===


" Override the default prefix of <leader>
"let g:fsharp_map_prefix = 'cp'
let g:fsharp_map_typecheck = 't'
let g:fsharp_map_typehelp = 'h'
let g:fsharp_map_gotodecl = 'g'
let g:fsharp_map_gobackfromdecl = 'b'
let g:fsharp_map_fsiinput = 'l'
"
let g:fsharp_map_fsisendline = 'e'
let g:fsharp_map_fsisendsel = 'e'

let g:LanguageClient_rootMarkers = ['*.cabal', 'stack.yaml']
let g:LanguageClient_serverCommands = {
    \ 'rust': ['rls'],
    \ 'haskell': ['ghcide', '--lsp'],
    \ 'ocaml': ['ocamllsp'],
    \ }

" bindings pour LSP client LanguageClient-neovim (in rust, autozimu)
nnoremap <F5> :call LanguageClient_contextMenu()<CR>
" Or map each action separately
nnoremap <silent> K :call LanguageClient#textDocument_hover()<CR>
nnoremap <silent> gd :call LanguageClient#textDocument_definition()<CR>
nnoremap <silent> <F2> :call LanguageClient#textDocument_rename()<CR>





" my own tweaks
"

" recommended by Syntastic plugin but how does it do ? 
"set statusline+=%#warningmsg#
"set statusline+=%{SyntasticStatuslineFlag()}
"set statusline+=%*
" .... and this .... 
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0




" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

" Put these in an autocmd group, so that we can delete them easily.
augroup vimrcEx
au!

" For all text files set 'textwidth' to 78 characters.
autocmd FileType text setlocal textwidth=78

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
  \ if line("'\"") >= 1 && line("'\"") <= line("$") |
  \   exe "normal! g`\"" |
  \ endif

augroup END


" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

" Prevent that the langmap option applies to characters that result from a
" mapping.  If unset (default), this may break plugins (but it's backward
" compatible).
if has('langmap') && exists('+langnoremap')
  set langnoremap
endif


" Moving lines up or down 
" In normal mode or in insert mode, press Alt-j to move the current line down, or press Alt-k to move the current line up.
nnoremap <C-j> :m .+1<CR>==
nnoremap <C-k> :m .-2<CR>==
inoremap <C-j> <Esc>:m .+1<CR>==gi
inoremap <C-k> <Esc>:m .-2<CR>==gi
vnoremap <C-j> :m '>+1<CR>gv=gv
vnoremap <C-k> :m '<-2<CR>gv=gv

" set relativenumber
set number

let mapleader = ","

" Clean Search
"elle existe d√©j√†" command C let @/=""

" reindet buffer
map <Leader>i mzgg=G`z

" Switch between Vim window splits easily
" Alt+arrow Navigation
" Alt+leftarrow will go one window left, etc.
" Alt A-* Shift S-*
nmap <silent> <A-Up> :wincmd k<CR>
nmap <silent> <A-Down> :wincmd j<CR>
nmap <silent> <A-Left> :wincmd h<CR>
nmap <silent> <A-Right> :wincmd l<CR>

" Maximize current window
" Rq: ^W ie CTRL-W supprime le mot avant le curseur en mode ins
" CTRL-W _	Set current window height to N (default: highest possible)
"map <F5> <C-W>_<C-W><Bar>

"highlight current line
nnoremap <Leader>l :set cursorline!<CR>

" voir hi ColorColumn
set colorcolumn=84

" :noh
" or :nohlsearch to temporarily disable search highlighting until the next search.
" To clear the last used search pattern:
"
" :let @/ = ""
" To turn off highlighting until the next search:
" 
" :noh
" Or turn off highlighting completely:
"
" set nohlsearch
" Or, to toggle it:
" 
" set hlsearch!
" ...
" nnoremap <F3> :set hlsearch!<CR>
nnoremap <Leader>n :nohlsearch<CR>

" remapped Shift-Tab so I could easily insert real tabs at the beginning of the line
inoremap <S-Tab> <C-V><Tab>

set tabstop=4
set expandtab
" makes the spaces feel like real tabs
"set softtabstop=4
set shiftwidth=4 

" What would be the chances that your keyboard sends an accented letter instead of a ` followed by a character? ‚Äì romainl Jan 10 '13 at 10:41
" @romainl. That is exactly what is happening. The keyboard driver is trying to send an accented letter. So it works with `<Space><mark>. Thanks for the help. ‚Äì Kei Jan 10 '13 at 17:34
" FYI: vim-signature does remap this by default: n `] * :<C-U>call signature#mark#Goto("next", "spot", "alpha")<CR> ‚Äì Keith Hughitt 

" PEBKAV (Problem Exists Between Keyboard And Vim)

" marks bug, linux is responsible
" partial workaround
nmap √† `a
nmap √Ä `A
" √†√®√´√ã√ä√™√™√™√®√®`z√®√® en rappelant celles qui ne renvoient rien  [`r`b] vs clavier [``r``b] 
nmap √® `e
nmap √à `E
nmap ·ª≥ `y
nmap ·ª≤ `Y
nmap √π `u
nmap √ô `U
nmap √¨ `i
nmap √å `I
nmap √≤ `o
nmap √í `O
nmap ·∫Å `w
nmap ·∫Ä `W
nmap √π `u
nmap √ô `U
nmap «π `n
nmap «∏ `N
" √†√®·ª≥√π√¨√≤·∫Å«ú«π directement, sinon entrer ^<Space> ou taper deux fois ^ pour que vim re√ßoive un ^


" Override the 'ignorecase' option if the search pattern contains upper case characters.
" Only used when the search pattern is typed and 'ignorecase' option is on.
set ignorecase
set smartcase

" === UNDO FILES ===
" turn undofiles ON
set undofile
set undodir=~/.local/share/nvim/undo//,.

" === SWAP FILES ===
" turn swap files ON
set directory=~/.local/share/nvim/swap//

" === BACKUP SETTINGS ===
" turn backup ON
"set backup
set backupcopy=yes
set writebackup
set backupdir=.,~/.local/share/nvim/backup

"'backup' 'writebackup'	action	
"   off	     off	no backup made
"   off	     on		backup current file, deleted afterwards (default)
"   on	     off	delete old backup, backup current file
"   on	     on		delete old backup, backup current file

"don't give the intro message when starting Vim |:intro|
set shortmess+=I

"If you need to define a block in visual block mode with bounds outside the actual text (that is, past the end of lines)
"The 'virtualedit' option can be used to allow positioning the cursor to positions where there is no actual character.
"block	Allow virtual editing in Visual block mode.
set virtualedit=block

"consistency with D, C
nnoremap Y y$

"cmd,filename completion like in shell
"'wildchar' option: A match is done on the pattern in front of the cursor.
set wildmode=longest,list

"avoid cursor from jumping around while J joining lines
"nnoremap J mzJ`z

" Manpage
" -= removes the value from a string list;
" += appends the value to a string list;
" ^= prepends the value to a string list.

" Vertical right delimiter, voir : hi VertSplit
set fillchars-=vert:\| | set fillchars+=vert:\ 


"automatically pairs string delimiter and position between them
"inoremap " ""<Esc>i


"=== CHAR SWAPPING ===
"To use gc to swap the current character with the next, without changing the cursor position:
nnoremap <silent> gc xph

"To use gw to swap the current word with the next, without changing cursor position
nnoremap <silent> gw "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o><c-l>:nohlsearch<CR>

"To use gl to swap the current word with the previous, keeping cursor on current word
nnoremap <silent> gl "_yiw?\w\+\_W\+\%#<CR>:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o><c-l>:nohlsearch<CR>

"To use gr to swap the current word with the next, keeping cursor on current word
nnoremap <silent> gr "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o>/\w\+\_W\+<CR><c-l>:nohlsearch<CR>

"To use g{ to swap the current paragraph with the next:
nnoremap g{ {dap}p{
""For ISO/IEC_8859-1 Latin-1 Supplement characters, substitute all \w instances with [0-9A-Za-z√Ä-√ñ√ò-√∂√∏-√ø_] and all  \_W instances with \_[^0-9A-Za-z√Ä-√ñ√ò-√∂√∏-√ø_]


" To use this mapping: first, delete,?yank a piece of texte. Then, use visual
" mode to select some other text piece, and press Ctrl-X. The two pieces of 
" text should then be swapped.
vnoremap <C-X> <Esc>`.``gvP``P


" delete without yanking
nnoremap <leader>d "_d
vnoremap <leader>d "_d

" replace currently selected text with default register
" without yanking it
vnoremap <leader>p "_dP
"_ is the "blackhole register", according to :help "_:
" vnoremap j'ai mis xnoremaps d'apr√®s la doc
" del,yank,change goes to "" et yank also goes to "0
" "_ is the blackhole register, thus the unnamed register "" is untouched
" 
" yank,..then ..      c  then  <C-R>0 
" yank and change by register |num|


"To display all the lines where the word under the cursor occurs, simply do in Normal mode: [I
" works in visual mode too for the visual highlight :
" Preliminary function helper definition :
function! OSearch(action)
  let c = v:count1
  if a:action[0] == "n"
    let s = "/\\<".expand("<cword>")."\\>/"
  elseif a:action[0] == "v"
    execute "normal! gvy"
    let s = "/\\V".substitute(escape(@@, "/\\"), "\n", "\\\\n", "g")."/"
    let diff = (line2byte("'>") + col("'>")) - (line2byte("'<") + col("'<"))
  endif
  if a:action[1] == "l"
    try
      execute "ilist! ".s
    catch
      if a:action[0] == "v"
        normal! gv
      endif
      return ""
    endtry
    let c = input("Go to: ")
    if c !~ "^[1-9]\\d*$"
      if a:action[0] == "v"
        normal! gv
      endif
      return ""
    endif
  endif
  let v:errmsg = ""
  silent! execute "ijump! ".c." ".s
  if v:errmsg == ""
    if a:action[0] == "v"
      " Initial version
      " execute "normal! ".visualmode().diff."\<Space>"
      " Bug fixfor single character visual [<Tab>:
      if diff
        execute "normal! ".visualmode().diff."\<Space>"
      else
        execute "normal! ".visualmode()
      endif
    endif
  elseif a:action[0] == "v"
    normal! gv
  endif
endfunction

nmap <silent>[I :<C-u>cal OSearch("nl")<CR>
""nmap <silent>[<Tab> :<C-u>cal OSearch("nj")<CR>
vmap <silent>[I :<C-u>cal OSearch("vl")<CR>
""vmap <silent>[<Tab> :<C-u>cal OSearch("vj")<CR>

"simple and flawed
"vnoremap // y/<C-R>"<CR>
"
"selected text is interpreted as regex, 
"thus . * etc must be escaped :
"use of \V , aka "very no-magic"
"vnoremap // y/\V<C-R>"<CR>
"
"still insufficient, \ backslash char will make it choke
"vnoremap <expr> // 'y/\V'.escape(@",'\').'<CR>'
"
"Press * to search forwards for selected text, or # to search backwards.
"As normal, press n for next search, or N for previous.
"Handles multiline selection and search.
"Whitespace in the selection matches any whitespace when searching (searching for "hello world" will also find "hello" at the end of a line, with "world" at the start of the next line).
"Each search is placed in the search history allowing you to easily repeat previous searches.
"No registers are changed.
"
" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>


" easy fold and forget, key <F9> (rempla√ß√© par <Leader>z )
inoremap <Leader>z <C-O>za
nnoremap <Leader>z za
onoremap <Leader>z <C-C>za
vnoremap <Leader>z zf

" Pick one safety clipboard hijacking insurance
inoremap <C-R>+ <C-R><C-R>+
"inoremap <C-R>+ <C-R><C-O>+
"inoremap <C-R>+ <C-G>u<C-\><C-O>"+gP
"inoremap <C-R>+ <C-G>ux<Esc>"=@+.'xy'<CR>gPFx"_2x"_s
"exe 'inoremap <script> <C-R>+ <C-G>u' . paste#paste_cmd['i']
"
"This illustrates the hijacking point. Executing the following puts some text in the a register.
"
":let @a = "abc\<Esc>:echo 'gotcha'\<CR>"
"
"After that, pressing i to enter insert mode, then typing Ctrl-R a inserts "abc" but then executes the echo command. The Vim procedure to insert the keys literally is to press Ctrl-R twice. That is, type Ctrl-R Ctrl-R a which will insert the escape and newline (carriage return) characters into the text

" Manpage
" in normal and visual mode, registers are pasted verbatim ! as is !
" in insert and command-line mode, registers are interpreted !
" mode ~= state+stream

"set tags=./.tags,.tags,./tags,tags
" nvim has 'tags' defaults to "./tags;,tags"

" PAS CLAIR
set hidden

"Use the directory of the related buffer 'browsedir bsdir option default: last
set browsedir=buffer

"set foldmethod=manual

" les deux lignes ci-dessous marche pas ?? (xdg-open n'appelle pas le bon env pq opam switch compiler etc ?)
let g:opamshare = substitute(system('opam config var share'),'\n$','','''')
execute "set rtp+=" . g:opamshare . "/merlin/vim"
":set rtp+=~/.opam/system/share/merlin/vim

"see last line


"set rtp^="/home/milvi/.opam/system/share/ocp-indent/vim"

" opamshare previously definied
" pour tout opam switch env
execute "set rtp^=" . g:opamshare . "/ocp-indent/vim"
"autocmd FileType ocaml source /home/milvi/.opam/system/share/ocp-indent/vim/indent/ocaml.vim

" opam install ocp-index 
" set rtp+=/home/milvi/.opam/4.08.1/share/ocp-index/vim
execute "set rtp^=" . g:opamshare . "/ocp-index/vim"

" " LAST LINE
"" should appear last, after loading package or plugin
"" adjustments
let g:syntastic_ocaml_checkers = ['merlin']

au FileType ocaml call SuperTabSetDefaultCompletionType("<c-x><c-o>")

let maplocalleader="\_"

"au Syntax ocaml runtime! syntax/ocaml.vim


"neoformat key binding
nnoremap <leader>f :Neoformat<CR>
"can't format intervals"vnoremap <silent> <leader>f :Neoformat<CR>


"let g:ghcid_command= 'ghcid --command="stack repl"'
" FIN
